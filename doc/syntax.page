# kramdown Syntax

The kramdown syntax is based on the Markdown syntax and the original Markdown.pl implementation and
has been enhanced with features that are found in other Markdown implementations like Maruku, PHP
Markdown Extra and Pandoc. However, it strives to provide a strict syntax with definite rules and
therefore isn't completely compatible with Markdown. Nonetheless, most Markdown documents should
work fine when parsed with kramdown. All places where the kramdown syntax differes from the Markdown
syntax are highlighted.

Following is the complete syntax definition so that you know what you will get when a kramdown
document is converted to HTML.

TODO: think about comment syntax (block comments, inline comments)
TODO: allow HTML sanitizing (excluding of attrs and/or tags from output)
TODO: what exactly are the punctuation characters????

## General

There are two types of elements: block level elements (paragraphs, blockquotes, ...) and span level
elements.

### Blank lines

Any line that just contains white space characters such as spaces and tabs is considered a blank
line by kramdown. Blank lines have normally no semantic meaning but are used to visually separate
block level elements from each other. The one case where blank lines have a meaning is when they are
used in lists -- see the [lists section](#lists) for more information.

### Error Behaviour

### Automatic Escaping

There are three characters in HTML syntax that need special treatment: `<`, `>` and `&`. When these
characters are used inside a code block or code span, they are always automatically escaped to their
HTML entity counterparts.

When used inside the normal text flow:

* `<` and `>` are always escaped except if they are part of an HTML tag, an XML processing
  instruction/comment or an autolink.
* `&` is escaped if it is not part of an HTML entity.

For example, the following fragment:

    This is the A&O. &copy; 2008 by me
    0 < 1 < 2 and 2 > 1 > 0

will be converted to:

    <p>This is the A&amp;O. &copy; 2008 by me
    0 &lt; 1 &lt; 2 and 2 &gt; 1 &gt; 0</p>


# Block Level Elements

Block level elements are used to structure the content. They can mark up some text, for example, as
code, as a quote or as list items.


## End-Of-Block Marker

The End-Of-Block (EOB) marker -- a `^` as first character on an otherwise empty line -- can be used
to specify the end of a block level element even if the block level element, after which it is used,
would continue otherwise. If there is no block to end, the EOB marker is simply ignored and the line
is considered a blank line.

You won't find an EOB marker in most kramdown documents but sometimes it is necessary to use it to
achieve the wanted results which would be impossible otherwise.

For example, the following gives you one list with two items:

    * list item one

    * list item two

By using an EOB marker, you can make two lists with each one item:

    * list one
    ^
    * list two

> The EOB marker is not part of the standard Markdown syntax.
{: .markdown-difference}

## Paragraphs

These are the most used block level elements. One or more consecutive lines of text are interpreted
as one paragraph. Each line of a paragraph may be indented up to three spaces. You can separate two
paragraphs from each other by using one or more blank lines. Notice that a line break in the source
does not mean a line break in the output. If you want to have an explicit line break (ie. a `<br />`
tag) you need to end a line with two spaces!

The following gives you an example of how paragraphs look like:

    This para line starts at the first column. However,
       it may be indented up to three spaces.
    The para continues here.

    This is another paragraph, not connected to the above one. But  
    with a hard line break.
{: .show-whitespaces}


## Headers

kramdown supports Setext style and atx style headers.

Setext style headers can be specified by a line of text (the header text) followed by a line with
only equal signs (for a first level header) or dashes (for a second level header). The header text
may be indented up to three spaces. The amount of equal signs or dashes is not significant, just one
is enough but more may look better. The equal signs or dashes have to begin at the first column. For
example:

    First level header
    ==================

    Second level header
    ------

       Other first level header
    =

You need to insert a blank line or an EOB marker if you want to follow a normal paragraph with a
Setext header, like this:

    This is a normal
    paragraph.

    And A Header
    ------------

This only applies when the last block element is a paragraph, so the following will produce a
blockquote followed by level two header for example:

    > This is a blockquote.
    And A Header
    ------------

However, it is generally a good idea to use a blank line before a Setext header because it looks
more approriate.

For another edge case consider the following example:

    header
    ---
    para

One might ask if this represents two paragraphs separated by a horizontal line or a second level
header and a paragraph. As suggested by the wording in the example, the latter is the case. So
the result of the above fragment is

    <h2>header</h2>
    <p>para</p>

The general rule is that Setext headers are processed before horizontal rules.

atx style headers can be specified by starting a line with one or more hash characters and then the
header text - no spaces are allowed before the hashes. The number of hash characters specifies the
heading level: one hash character gives you a first level heading, two a second level heading and so
on till the maximum of six hash characters for a sixth level heading. You may optionally use any
number of hashes at the end of the line to close the header. For example:

    # First level header

    ### Third level header ###

    ## Second level header ######

Kramdown supports the automatic generation of header IDs if the option `:auto_ids` is set to `true`.
This is done by converting the untransformed header text via the following steps:

* All characters except letters, numbers, spaces and underscores are removed.
* All characters from the start of the line till the first letter are removed.
* All spaces are converted to underscores.
* Everything is downcased.

So, for example, the following text snippet with `:auto_ids` set to `true`

    # This is a header

    ## 12. Another one 1 here

    ### Do ^& it now

    Hallo
    =====

    Not now
    -------

gets converted to:

    <h1 id="this_is_a_header">This is a header</h1>

    <h2 id="another_one_1_here">12. Another one 1 here</h2>

    <h3 id="do__it_now">Do ^&amp; it now</h3>

    <h1 id="hallo">Hallo</h1>

    <h2 id="not_now">Not now</h2>


## Blockquotes

A blockquote is started using the `>` marker followed by an optional space. The marker itself may be
indented up to three space. All following lines that are also started with the blockquote marker
belong to the blockquote. The contents of a blockquote are block level elements. This means that if
you are just using text as content that it will be wrapped in a paragraph. For example, the
following gives you one blockquote with two paragraphs in it:

    > This is a blockquote.
    >on multiple lines.
    >
    > This is the second paragraph.

Since the contents of a blockquote are block level elements, you can nest blockquote and use other
block level elements:

    > This is a paragraph.
    > > A nested blockquote.
    >
    > ## Headers work
    > * lists too
    >
    > and all other block level elements

Note that the first space character after the `>` marker does not count when counting spaces for the
indentation of the block level elements inside the blockquote! So code blocks will have to be
indented with five space or one space and one tab, like this:

    > A code block:
    >     ruby -e 'puts :works'

> The original Markdown syntax allowed "lazy" blockquotes, ie. blockquotes where only the first line
> needs a blockquote marker. This is disallowed in kramdown, you always need to use a blockquote
> marker! The rational behind this is that most email programs put the `>` maker before every quoted
> line and that things like the following work like expected:
>
>     > > This is some quoted text.
>     > > Spanning multiple lines.
>     > This is the answer to the quoted text above.
>     This is just a normal paragraph, with the answer to the above.
{: .markdown-difference}


## Code Blocks

Code blocks can be used to represent verbatim text like markup, HTML or a program fragment. No
syntax is parsed within a code block, only `<`, `>` and `&` are substituted by their respective HTML
counterparts. A code block is wrapped in both `<pre>` and  `<code>` tags.

A code block can be started by using four spaces or one tab and then the text of the code block. All
following lines that adhere to this syntax belong to the same code block. The indentation is
stripped from the text. Note that blank lines don't separate consecutive code blocks:

        Here comes some code

        This text belongs to the same code block.

If you want to have one code block directly after another one, you need to use an EOB marker to
separate the two:

        Here comes some code
    ^
        This one is separate.

kramdown also supports an alternative syntax for code blocks which does not use indented blocks but
delimiting lines. The starting line needs to begin with three or more tildes (`~`) and the closing
line needs to have at least the number of tildes the starting line has. Everything between is taken
literally as with the other syntax but there is no need for indenting the text. For example:

    ~~~~~~~~
    Here comes some code.
    ~~~~~~~~

If you need lines of tildes in such a code block, just start the code block with more tildes. For
example:

    ~~~~~~~~~~~~
    ~~~~~~~
    code with tildes
    ~~~~~~~~
    ~~~~~~~~~~~~~~~~~~

This type of code block is especially useful for copy-pasted code since you don't need to indent the
code.

> The alternative syntax is not part of the original Markdown syntax. The idea was taken from the
> PHP Markdown Extra package.
{: .markdown-difference}


## Horizontal Rules

A horizontal rule is created by using three or more asterisks, dashes or underscores, optionally
separated by spaces or tabs, on an otherwise blank line. The first asterisk, dash or underscore may
optionally be indented up to three spaces. The following examples show different possibilities to
create a horizontal rule:

   * * *

   ---

   _  _  _  _

   ---------------


## Lists

Both ordered and unordered lists follow the same rules.

A list is started with a list marker (in case of unordered lists one of `+`, `-` or `*` -- you can
mix them -- and in case of ordered lists a number followed by a period) followed by one tab or at
least one space and then the first part of the content of the list item. The leading tab or the
leading spaces up to the fourth column are stripped away from this content (to allow for a nice
alignment with the following content of a list item, see below). All following list items with the
same marker type (unordered or ordered) are put into the same list. The numbers used for ordered
lists are irrelevant, a converted ordered list always starts at 1.

The following gives you an unordered list and an ordered list:

    * kram
    + down
    - now

    1. kram
    2. down
    3. now

> The original Markdown syntax allows the markers of ordered and unordered lists to be mixed, the
> first marker specifying the list type (ordered or unordered). This is not allowed in kramdown. As
> stated the above example will give you two lists (an unordered and an ordered) in kramdown and
> only one unordered list in Markdown.
{: .markdown-difference}

Each list marker may be indented up to three spaces. So, while the following is possible and creates
one list with two items, it is not advised to use different indents for same level list items:

    * kram
       + down

> The original Markdown syntax also allows you to indent the marker, however, the behaviour of what
> happens with the list items is not clearly specified and may surprise you.
{: .markdown-difference}

The content of a list item is made up of either text or block level elements. Simple list items only
contain text like in the above examples. They are not even wrapped in a paragraph tag. If the first
list text is followed by one or more blank lines, it will be wrapped in a paragraph tag:

    * kram

    * down

In the above example, the first list item textwill be wrapped in a paragraph tag since it is
followed by a blank line. There is obviously a problem for doing this with the last list item when
it contains only text. You can circumvent this by leaving a blank line after the last list item and
using an EOB marker:

    * Not wrapped in a paragraph
    * Wrapped in a paragraph due to the following blank line.

    * Also wrapped in a paragraph due to the
      following blank line and the EOB marker.

    ^

> The original Markdown syntax page specifies that list items which are separated by one or more
> blank lines are wrapped in paragraph tags. This means that the first text will also be wrapped in
> a paragraph if you have block level elements in a list which are separated by blank lines. The
> above rule is easy to remember and lets you exactly specify when the first list text should be
> wrapped in a paragraph. The idea for the above rule comes from the TODO(i think it was pandoc?)
> package.
{: .markdown-difference}

As seen in the examples above, blank lines between list items are allowed.

The first element in a list item is normally just text or a paragraph but you can also have any
other block level element as first element in a list item. This is due to the following: every line
after a list item which is blank or indented with one tab or four spaces is part of the list item
content. The first four spaces or one tab are stripped away from each line and the result (note that
the result naturally also contains the content of the line with the item marker) is processed as
text containing block level elements.

This allows you to add block level element to list items as well as continue the content of a list
item after a blank line. For example:

    *   First item

        A second paragraph

        * nested list
        > blockquote

    *   Second item

But this obviously results in a problem when you want to follow a list item immediately with a code
block. You can use an EOB marker to circumvent this problem:

    *   This is a list item.

        The second para of the list item.
    ^
        A code block following the list item.

You can have any block level element as first element in a list item. As described above, the first
tab or the spaces up to the fourth column of the line with the list item marker are stripped away.
So, for example, to insert a code block as first element follow the item marker with 7 spaces (3
spaces are stripped away because the asterisk is in column one) or 2 tabs:

    *       This is a code block.
    *   > This is a blockquote.

> The original Markdown implementation strips away all leading spaces/tabs of the line with the list
> item marker. This makes it impossible to have a code block as first element.
{: .markdown-difference}

There is one exception to the above: you may be lazy with the text in the lines immediately
following the line with the list item marker:

    * First list item
    continued here
    *   Second list item
        continued here.

Normally, the second line in the above example would start a paragraph and therefore end the list.
This behaviour is changed to allow the author to be lazy. This rule is an exception to the design of
the kramdown syntax and is only used because writing lists in this manner is very common.

However, this rule also means that you will need to use an EOB marker or insert a blank line if you
want to follow a list item immediately with a paragraph:

    * This is a list
    ^
    Followed by a paragraph.

    * Another list

    Followed by another paragraph.

If you want to have one list directly after another one (both with the same list type, ie. ordered
or unordered), you need to use an EOB marker to separate the two:

    * List one
    ^
    * List two

It is possible that a line gets parsed as ordered or unordered list although it shouldn't. This
would be the case in the following example:

    I have read the book
    1984. It was great
    - others say that, too!

To avoid this, there is the following special rule:

* If a paragraph is directly followed by a list, ie. without a blank line or an EOB marker, the
  first list item marker needs to be indented at least two spaces (ie. exactly two or three spaces).

Therefore the above example will be parsed correctly as one paragraph. The rational behind this is
that nearly all editors wrap lines sothat the first character of the new line is a non-white-space
character and this may result in the first character being a list item marker.

This also has implications when you want to have compact nested lists. You will need to indent the
list marker for the nested list either one tab and two/three spaces or six/seven spaces, like this:

    *   This is just text.
        * this is not a list item (only 4 spaces, stripping leaves 0 spaces)
    *     This is just text.
          * This is a nested list item. (6 spaces, stripping leaves 2 spaces)

Another way to remedy the problem with the list item marker in text is by escaping the period in an
ordered list or the list item marker in an unordered list (this is especially useful when the
paragraph starts with something looking like a list item marker):

    1984\. It was great
    \- others say that, too!


## Divisions

TODO: REDO section/implement it
Divisions (`div` elements in HTML) can be used to separate content into various structural parts. A
division is started by using a plus character followed by two or more equal signs. The end of a
division can be specified by using a minus character followed again by two or more equal
signs. These start and end markers may be indented up to three spaces. Note that you don't need to
(more precisely: you shouldn't) indent the content of a division! This allows you to easily add
divisons after writing the text. Nesting of divisions is also possible.

Two nested divisions:

    +====
    A para here.
      +==
    And another para.
    -========
       -==
^
    <div>
      <p>A para here.</p>

      <div>
        <p>And another para.</p>
      </div>
    </div>


## HTML Blocks

There is no problem mixing HTML tags into a kramdown document. An HTML block is started when
kramdown encounters a line with a block level HTML tag (`div`, `p`, `pre`, ...) which may be
indented up to three spaces. The HTML block continues till the matching end tag of that first HTML
tag is encountered. Note that only correct XHTML is supported! This means that you have to use, for
example, `<br/>` instead of `<br>`.

> The original Markdown syntax specifies that an HTML block must start at the left margin, ie. no
> indentation is allowed. Also, the HTML block has to be surrounded by blank lines. Both
> restrictions are lifted for kramdown documents.
{: .markdown-difference}

This fragment

    This is a para.
    <div>
      Something in here.
    </div>
    Other para.

gives you this output:

    <p>This is a para.</p>
    <div>
      Something in here.
    </div>
    <p>Other para.</p>

If you don't use valid XHTML tags, you won't get expected result (note the invalid `<br>` tag):

    This is a para.
    <div>
      Something is<br>
      broken here.
    </div>
    This won't be a para.
^
    <p>This is a para.</p>
    <div>
      Something is<br>
      broken here.
    </div>
    This won't be a para.

The parsing of processing instructions and XML comments is also supported. kramdown syntax in such
processing instructions or comments is not processed:

    This is a para.
    <!-- a *comment* -->
    <? a processing `instruction` ?>
    Another para.
^
    <p>This is a para.</p>
    <!-- a *comment* -->
    <? a processing `instruction` ?>
    <p>Another para.</p>

TODO: allow processing of syntax in HTML blocks, mention it in differences


# Span Level Elements

These elements are used inside block level elements to markup text fragments. For example, one can
easily create links or apply emphasis to certain text parts.

Empty span level elements are not converted to empty HTML tags but are copied as-is to the output.

TODO: check the above claim for all span level elements

## Links and Images

Two styles of links are supported: inline and reference.

As the wording suggests, inline links provide all information inline in the text flow. Reference
style links only provide the link text in the text flow and everything else is defined
elsewhere. This also allows you to reuse link definitions.

An inline style link can be created by surrounding the link text with square brackets, followed
immediately by the link URL (and an optional title in single or double quotes surrounded by optional
spaces/tabs) in normal parentheses. For example:

    This is [a link](http://rubyforge.org) to a page.
    A [link](../test "local URI") can also have a title.

Notes:

* The link text is treated like normal span level text and therefore is parsed and converted.
  However, if you use square brackets within the link text, you have to either properly nest them or
  to escape them. It is not possible to create nested links!

* The link URL must not contain any spaces and it has to contain properly nested parentheses if no
  title is specified. There must not be any spaces before the link URL, and if no title is
  specified, no spaces are allowed between the link URL and the closing parenthesis.

* The link title may not contain its delimiters and may not be empty.

> In contrast to the original Markdown syntax, the link URL may not be enclosed in angle brackets,
> neither in inline links nor in link definitions.
{: .markdown-difference}

TODO: maybe lift the above restraints
TODO: specify exactly the allowed punctuation characters

To create a reference style link, you need to surround the link text with square brackets (as with
inline links), followed by optional spaces/tabs/line breaks and then optionally followed with
another set of square brackets with the link identifier in them. A link indentifier may only contain
numbers, letters, spaces and punctuation characters and is not case sensitive. For example:

    This is a [reference style link][linkid] to a page. And [this]
    [linkid] is also a link. As is [this][] and [THIS].

If you don't specify a link identifier (ie. only use empty square brackets) or completely omit the
second pair of square brackets, the link text is converted to a valid link identifier by removing
all invalid characters and inserting spaces for line breaks. If there is a link definition found for
the link identifier, a link will be created. Otherwise the text is not converted to a link.

The link definition can be put anywhere in the document. It does not appear in the output. A link
definition looks like this:

    [linkid]: http://www.example.com/ "Optional Title"

The link definition has the following structure:

* The link identifier in square brackets, optionally indented up to three spaces,
* then a colon and one or more spaces/tabs,
* then the link URL,
* then optionally the title in single or double quotes, separated from the link URL by one or more
  spaces or on the next line by itself indented any number of spaces/tabs.

> The original Markdown syntax also allowed the title to be specified in parenthesis. This is not
> allowed for consistency with the inline title.
{: .markdown-difference}

Images can be specified via a syntax that is similar to the one used by links. The difference is
that you have to use an exclamation mark before the first square bracket and that the link text of a
normal link becomes the alternative text of the image link. As with normal links, image links can be
written inline or reference style. For example:

    Here comes a ![smiley](../images/smiley.png)! And here
    ![too](../images/other.png 'Title text'). Or ![here].

The link definition for images is exactly the same as the link definition for normal links.


## Emphasis

kramdown uses the HTML elements `em` and `strong` to style emphasized text parts. Text parts that
are surrounded with single asterisks `*` or underscores `_` are wrapped in `em` tags, text parts
surrounded with two asterisks or underscores are wrapped in `strong` tags. For example:

    *some text*
    _some text*
    **some text**
    __some text__

will produce the following output:

    <em>some text</em>
    <em>some text</em>
    <strong>some text</strong>
    <strong>some text</strong>

This also works when used within a single word:

    This is un*believe*able!

Text emphasized with different delimiters can be nested but you can't nest emphasized text with the
same delimiters:

    This is a ***strong and emphasized*** text.
    This **is __very__ strong**.
    This **is **very** strong**.

will produce the following output:

    <p>This is a <strong><em>strong and emphasized</em></strong> text.
    This <strong>is <strong>very</strong> strong</strong>.
    This <strong>is </strong>very<strong> strong</strong>.</p>

Notice the difference between the second and the third line!

If one or two asterisks or underscores are surrounded by spaces, they are treated literally. If you
want to force the literal meaning of an asterisk or an underscore you can backslash-escape it:

    This is a * literal asterisk.
    These are ** two literal asterisk.
    As \*are\* these!


## Code Spans

This is the span level equivalent of the code block element. You can markup a text part as code span
by surrounding it with backticks `` ` ``. For example:

    Use `<html>` tags for this.

The special characters `<`, `>` and `&` are substituted by their respective HTML counterparts (same
behaviour as seen with the block level code block element).

To include a literal backtick in a code span, you need to use two or more backticks as delimiters.
You can insert one optional space after the starting and before the ending delimiter (these spaces
are not used in the output). For example:

    Here is a literal `` ` `` backtick.
    And here is ``  `some`  `` text (note the two spaces!).

will produce:

    <p>Here is a literal <code>`</code> backtick.</p>
    <p>And here is <code> `some` </code> text (note the two spaces!).</p>

A single backtick surrounded by spaces is treated as literal backtick. If you want to force the
literal meaning of a backtick you can backslash-escape it:

    This is a ` literal backtick.
    As \`are\` these!


# Miscellaneous

## Escaping

Since kramdown uses some characters to mark-up the text, there need to be a way to escape these
special characters sothat they have their normal meaning. This can be done by using backslash
escapes. For example, you can use a literal backtick like this:

    This \`is not a code\` span!

Following is a list of all those characters that can be escaped:

    \\ backslash
    .  period
    *  asterisk
    _  underscore
    `  backtick

TODO: complete list
